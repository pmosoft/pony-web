{"remainingRequest":"D:\\fframe\\workspace\\pony-web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\fframe\\workspace\\pony-web\\node_modules\\ag-grid-community\\dist\\lib\\rowModels\\clientSide\\clientSideRowModel.js","dependencies":[{"path":"D:\\fframe\\workspace\\pony-web\\node_modules\\ag-grid-community\\dist\\lib\\rowModels\\clientSide\\clientSideRowModel.js","mtime":1566387878512},{"path":"D:\\fframe\\workspace\\pony-web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1566388048828},{"path":"D:\\fframe\\workspace\\pony-web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1566387884895}],"contextDependencies":[],"result":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../../utils\");\nvar constants_1 = require(\"../../constants\");\nvar gridOptionsWrapper_1 = require(\"../../gridOptionsWrapper\");\nvar columnApi_1 = require(\"../../columnController/columnApi\");\nvar columnController_1 = require(\"../../columnController/columnController\");\nvar filterManager_1 = require(\"../../filter/filterManager\");\nvar rowNode_1 = require(\"../../entities/rowNode\");\nvar eventService_1 = require(\"../../eventService\");\nvar events_1 = require(\"../../events\");\nvar context_1 = require(\"../../context/context\");\nvar selectionController_1 = require(\"../../selectionController\");\nvar clientSideNodeManager_1 = require(\"./clientSideNodeManager\");\nvar changedPath_1 = require(\"./changedPath\");\nvar valueService_1 = require(\"../../valueService/valueService\");\nvar valueCache_1 = require(\"../../valueService/valueCache\");\nvar gridApi_1 = require(\"../../gridApi\");\nvar RecursionType = /*@__PURE__*/ (function (RecursionType) {\n    RecursionType[RecursionType[\"Normal\"] = 0] = \"Normal\";\n    RecursionType[RecursionType[\"AfterFilter\"] = 1] = \"AfterFilter\";\n    RecursionType[RecursionType[\"AfterFilterAndSort\"] = 2] = \"AfterFilterAndSort\";\n    RecursionType[RecursionType[\"PivotNodes\"] = 3] = \"PivotNodes\";\n    return RecursionType;\n})(RecursionType || (RecursionType = {}));\nvar ClientSideRowModel = /*@__PURE__*/ (function () {\n    function ClientSideRowModel() {\n    }\n    ClientSideRowModel.prototype.init = function () {\n        var refreshEverythingFunc = this.refreshModel.bind(this, { step: constants_1.Constants.STEP_EVERYTHING });\n        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, refreshEverythingFunc);\n        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);\n        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: constants_1.Constants.STEP_PIVOT }));\n        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));\n        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);\n        var refreshMapFunc = this.refreshModel.bind(this, { step: constants_1.Constants.STEP_MAP, keepRenderedRows: true, animate: true });\n        this.gridOptionsWrapper.addEventListener(gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN, refreshMapFunc);\n        this.gridOptionsWrapper.addEventListener(gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, refreshMapFunc);\n        this.rootNode = new rowNode_1.RowNode();\n        this.nodeManager = new clientSideNodeManager_1.ClientSideNodeManager(this.rootNode, this.gridOptionsWrapper, this.context, this.eventService, this.columnController, this.gridApi, this.columnApi, this.selectionController);\n        this.context.wireBean(this.rootNode);\n    };\n    // returns false if row was moved, otherwise true\n    ClientSideRowModel.prototype.ensureRowAtPixel = function (rowNode, pixel) {\n        var indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n        var rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n        if (rowNodeAtPixelNow === rowNode) {\n            return false;\n        }\n        utils_1.Utils.removeFromArray(this.rootNode.allLeafChildren, rowNode);\n        utils_1.Utils.insertIntoArray(this.rootNode.allLeafChildren, rowNode, indexAtPixelNow);\n        this.refreshModel({ step: constants_1.Constants.STEP_EVERYTHING, keepRenderedRows: true, animate: true, keepEditingRows: true });\n        return true;\n    };\n    ClientSideRowModel.prototype.isLastRowFound = function () {\n        return true;\n    };\n    ClientSideRowModel.prototype.getRowCount = function () {\n        if (this.rowsToDisplay) {\n            return this.rowsToDisplay.length;\n        }\n        else {\n            return 0;\n        }\n    };\n    ClientSideRowModel.prototype.getRowBounds = function (index) {\n        if (utils_1.Utils.missing(this.rowsToDisplay)) {\n            return null;\n        }\n        var rowNode = this.rowsToDisplay[index];\n        if (rowNode) {\n            return {\n                rowTop: rowNode.rowTop,\n                rowHeight: rowNode.rowHeight\n            };\n        }\n        else {\n            return null;\n        }\n    };\n    ClientSideRowModel.prototype.onRowGroupOpened = function () {\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: constants_1.Constants.STEP_MAP, keepRenderedRows: true, animate: animate });\n    };\n    ClientSideRowModel.prototype.onFilterChanged = function () {\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: constants_1.Constants.STEP_FILTER, keepRenderedRows: true, animate: animate });\n    };\n    ClientSideRowModel.prototype.onSortChanged = function () {\n        // we only act on the sort event here if the user is doing in grid sorting.\n        // we ignore it if the sorting is happening on the server side.\n        if (this.gridOptionsWrapper.isEnableServerSideSorting()) {\n            return;\n        }\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: constants_1.Constants.STEP_SORT, keepRenderedRows: true, animate: animate, keepEditingRows: true });\n    };\n    ClientSideRowModel.prototype.getType = function () {\n        return constants_1.Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n    };\n    ClientSideRowModel.prototype.onValueChanged = function () {\n        if (this.columnController.isPivotActive()) {\n            this.refreshModel({ step: constants_1.Constants.STEP_PIVOT });\n        }\n        else {\n            this.refreshModel({ step: constants_1.Constants.STEP_AGGREGATE });\n        }\n    };\n    ClientSideRowModel.prototype.createChangePath = function (rowNodeTransactions) {\n        // for updates, if the row is updated at all, then we re-calc all the values\n        // in that row. we could compare each value to each old value, however if we\n        // did this, we would be calling the valueService twice, once on the old value\n        // and once on the new value. so it's less valueGetter calls if we just assume\n        // each column is different. that way the changedPath is used so that only\n        // the impacted parent rows are recalculated, parents who's children have\n        // not changed are not impacted.\n        var valueColumns = this.columnController.getValueColumns();\n        var noValueColumns = utils_1.Utils.missingOrEmpty(valueColumns);\n        var noTransactions = utils_1.Utils.missingOrEmpty(rowNodeTransactions);\n        var changedPath = new changedPath_1.ChangedPath(false);\n        if (noValueColumns || noTransactions) {\n            changedPath.setInactive();\n        }\n        return changedPath;\n    };\n    ClientSideRowModel.prototype.refreshModel = function (params) {\n        // this goes through the pipeline of stages. what's in my head is similar\n        // to the diagram on this page:\n        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n        // however we want to keep the results of each stage, hence we manually call\n        // each step rather than have them chain each other.\n        var _this = this;\n        // fallthrough in below switch is on purpose,\n        // eg if STEP_FILTER, then all steps below this\n        // step get done\n        // let start: number;\n        // console.log('======= start =======');\n        var changedPath = this.createChangePath(params.rowNodeTransactions);\n        switch (params.step) {\n            case constants_1.Constants.STEP_EVERYTHING:\n                // start = new Date().getTime();\n                this.doRowGrouping(params.groupState, params.rowNodeTransactions, params.rowNodeOrder, changedPath);\n            // console.log('rowGrouping = ' + (new Date().getTime() - start));\n            case constants_1.Constants.STEP_FILTER:\n                // start = new Date().getTime();\n                this.doFilter();\n            // console.log('filter = ' + (new Date().getTime() - start));\n            case constants_1.Constants.STEP_PIVOT:\n                this.doPivot(changedPath);\n            case constants_1.Constants.STEP_AGGREGATE:// depends on agg fields\n                // start = new Date().getTime();\n                this.doAggregate(changedPath);\n            // console.log('aggregation = ' + (new Date().getTime() - start));\n            case constants_1.Constants.STEP_SORT:\n                // start = new Date().getTime();\n                this.doSort();\n            // console.log('sort = ' + (new Date().getTime() - start));\n            case constants_1.Constants.STEP_MAP:\n                // start = new Date().getTime();\n                this.doRowsToDisplay();\n        }\n        var event = {\n            type: events_1.Events.EVENT_MODEL_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            animate: params.animate,\n            keepRenderedRows: params.keepRenderedRows,\n            newData: params.newData,\n            newPage: false\n        };\n        this.eventService.dispatchEvent(event);\n        if (this.$scope) {\n            setTimeout(function () {\n                _this.$scope.$apply();\n            }, 0);\n        }\n    };\n    ClientSideRowModel.prototype.isEmpty = function () {\n        var rowsMissing;\n        var doingLegacyTreeData = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n        if (doingLegacyTreeData) {\n            rowsMissing = utils_1.Utils.missing(this.rootNode.childrenAfterGroup) || this.rootNode.childrenAfterGroup.length === 0;\n        }\n        else {\n            rowsMissing = utils_1.Utils.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n        }\n        var empty = utils_1.Utils.missing(this.rootNode) || rowsMissing || !this.columnController.isReady();\n        return empty;\n    };\n    ClientSideRowModel.prototype.isRowsToRender = function () {\n        return utils_1.Utils.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n    };\n    ClientSideRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n        // if lastSelectedNode is missing, we start at the first row\n        var firstRowHit = !lastInRange;\n        var lastRowHit = false;\n        var lastRow;\n        var result = [];\n        var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n        this.forEachNodeAfterFilterAndSort(function (rowNode) {\n            var lookingForLastRow = firstRowHit && !lastRowHit;\n            // check if we need to flip the select switch\n            if (!firstRowHit) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    firstRowHit = true;\n                }\n            }\n            var skipThisGroupNode = rowNode.group && groupsSelectChildren;\n            if (!skipThisGroupNode) {\n                var inRange = firstRowHit && !lastRowHit;\n                var childOfLastRow = rowNode.isParentOfNode(lastRow);\n                if (inRange || childOfLastRow) {\n                    result.push(rowNode);\n                }\n            }\n            if (lookingForLastRow) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    lastRowHit = true;\n                    if (rowNode === lastInRange) {\n                        lastRow = lastInRange;\n                    }\n                    else {\n                        lastRow = firstInRange;\n                    }\n                }\n            }\n        });\n        return result;\n    };\n    ClientSideRowModel.prototype.setDatasource = function (datasource) {\n        console.error('ag-Grid: should never call setDatasource on clientSideRowController');\n    };\n    ClientSideRowModel.prototype.getTopLevelNodes = function () {\n        return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n    };\n    ClientSideRowModel.prototype.getRootNode = function () {\n        return this.rootNode;\n    };\n    ClientSideRowModel.prototype.getRow = function (index) {\n        return this.rowsToDisplay[index];\n    };\n    ClientSideRowModel.prototype.isRowPresent = function (rowNode) {\n        return this.rowsToDisplay.indexOf(rowNode) >= 0;\n    };\n    ClientSideRowModel.prototype.getVirtualRowCount = function () {\n        console.warn('ag-Grid: rowModel.getVirtualRowCount() is not longer a function, use rowModel.getRowCount() instead');\n        return this.getPageLastRow();\n    };\n    ClientSideRowModel.prototype.getPageFirstRow = function () {\n        return 0;\n    };\n    ClientSideRowModel.prototype.getPageLastRow = function () {\n        if (this.rowsToDisplay) {\n            return this.rowsToDisplay.length - 1;\n        }\n        else {\n            return 0;\n        }\n    };\n    ClientSideRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {\n        if (this.isEmpty()) {\n            return -1;\n        }\n        // do binary search of tree\n        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n        var bottomPointer = 0;\n        var topPointer = this.rowsToDisplay.length - 1;\n        // quick check, if the pixel is out of bounds, then return last row\n        if (pixelToMatch <= 0) {\n            // if pixel is less than or equal zero, it's always the first row\n            return 0;\n        }\n        var lastNode = this.rowsToDisplay[this.rowsToDisplay.length - 1];\n        if (lastNode.rowTop <= pixelToMatch) {\n            return this.rowsToDisplay.length - 1;\n        }\n        while (true) {\n            var midPointer = Math.floor((bottomPointer + topPointer) / 2);\n            var currentRowNode = this.rowsToDisplay[midPointer];\n            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n                return midPointer;\n            }\n            else if (currentRowNode.rowTop < pixelToMatch) {\n                bottomPointer = midPointer + 1;\n            }\n            else if (currentRowNode.rowTop > pixelToMatch) {\n                topPointer = midPointer - 1;\n            }\n        }\n    };\n    ClientSideRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {\n        var topPixel = rowNode.rowTop;\n        var bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n        var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n        return pixelInRow;\n    };\n    ClientSideRowModel.prototype.getCurrentPageHeight = function () {\n        if (this.rowsToDisplay && this.rowsToDisplay.length > 0) {\n            var lastRow = this.rowsToDisplay[this.rowsToDisplay.length - 1];\n            var lastPixel = lastRow.rowTop + lastRow.rowHeight;\n            return lastPixel;\n        }\n        else {\n            return 0;\n        }\n    };\n    ClientSideRowModel.prototype.forEachLeafNode = function (callback) {\n        if (this.rootNode.allLeafChildren) {\n            this.rootNode.allLeafChildren.forEach(function (rowNode, index) { return callback(rowNode, index); });\n        }\n    };\n    ClientSideRowModel.prototype.forEachNode = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);\n    };\n    ClientSideRowModel.prototype.forEachNodeAfterFilter = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);\n    };\n    ClientSideRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);\n    };\n    ClientSideRowModel.prototype.forEachPivotNode = function (callback) {\n        this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);\n    };\n    // iterates through each item in memory, and calls the callback function\n    // nodes - the rowNodes to traverse\n    // callback - the user provided callback\n    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n    // index - works similar to the index in forEach in javascripts array function\n    ClientSideRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {\n        if (nodes) {\n            for (var i = 0; i < nodes.length; i++) {\n                var node = nodes[i];\n                callback(node, index++);\n                // go to the next level if it is a group\n                if (node.hasChildren()) {\n                    // depending on the recursion type, we pick a difference set of children\n                    var nodeChildren = void 0;\n                    switch (recursionType) {\n                        case RecursionType.Normal:\n                            nodeChildren = node.childrenAfterGroup;\n                            break;\n                        case RecursionType.AfterFilter:\n                            nodeChildren = node.childrenAfterFilter;\n                            break;\n                        case RecursionType.AfterFilterAndSort:\n                            nodeChildren = node.childrenAfterSort;\n                            break;\n                        case RecursionType.PivotNodes:\n                            // for pivot, we don't go below leafGroup levels\n                            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n                            break;\n                    }\n                    if (nodeChildren) {\n                        index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);\n                    }\n                }\n            }\n        }\n        return index;\n    };\n    // it's possible to recompute the aggregate without doing the other parts\n    // + gridApi.recomputeAggregates()\n    ClientSideRowModel.prototype.doAggregate = function (changedPath) {\n        if (this.aggregationStage) {\n            this.aggregationStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    };\n    // + gridApi.expandAll()\n    // + gridApi.collapseAll()\n    ClientSideRowModel.prototype.expandOrCollapseAll = function (expand) {\n        var usingTreeData = this.gridOptionsWrapper.isTreeData();\n        if (this.rootNode) {\n            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n        }\n        function recursiveExpandOrCollapse(rowNodes) {\n            if (!rowNodes) {\n                return;\n            }\n            rowNodes.forEach(function (rowNode) {\n                var shouldExpandOrCollapse = usingTreeData ? utils_1.Utils.exists(rowNode.childrenAfterGroup) : rowNode.group;\n                if (shouldExpandOrCollapse) {\n                    rowNode.expanded = expand;\n                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n                }\n            });\n        }\n        this.refreshModel({ step: constants_1.Constants.STEP_MAP });\n        var eventSource = expand ? 'expandAll' : 'collapseAll';\n        var event = {\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            type: events_1.Events.EVENT_EXPAND_COLLAPSE_ALL,\n            source: eventSource\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ClientSideRowModel.prototype.doSort = function () {\n        this.sortStage.execute({ rowNode: this.rootNode });\n    };\n    ClientSideRowModel.prototype.doRowGrouping = function (groupState, rowNodeTransactions, rowNodeOrder, changedPath) {\n        var _this = this;\n        // grouping is enterprise only, so if service missing, skip the step\n        var doingLegacyTreeData = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n        if (doingLegacyTreeData) {\n            return;\n        }\n        if (this.groupStage) {\n            if (utils_1.Utils.exists(rowNodeTransactions)) {\n                rowNodeTransactions.forEach(function (tran) {\n                    _this.groupStage.execute({ rowNode: _this.rootNode,\n                        rowNodeTransaction: tran,\n                        rowNodeOrder: rowNodeOrder,\n                        changedPath: changedPath });\n                });\n            }\n            else {\n                // groups are about to get disposed, so need to deselect any that are selected\n                this.selectionController.removeGroupsFromSelection();\n                this.groupStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n                // set open/closed state on groups\n                this.restoreGroupState(groupState);\n            }\n            if (this.gridOptionsWrapper.isGroupSelectsChildren()) {\n                this.selectionController.updateGroupsFromChildrenSelections();\n            }\n        }\n        else {\n            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n        }\n    };\n    ClientSideRowModel.prototype.restoreGroupState = function (groupState) {\n        if (!groupState) {\n            return;\n        }\n        utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n            // if the group was open last time, then open it this time. however\n            // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'\n            // setting will take effect.\n            if (typeof groupState[key] === 'boolean') {\n                node.expanded = groupState[key];\n            }\n        });\n    };\n    ClientSideRowModel.prototype.doFilter = function () {\n        this.filterStage.execute({ rowNode: this.rootNode });\n    };\n    ClientSideRowModel.prototype.doPivot = function (changedPath) {\n        if (this.pivotStage) {\n            this.pivotStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    };\n    ClientSideRowModel.prototype.getGroupState = function () {\n        if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {\n            return null;\n        }\n        var result = {};\n        utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) { return result[key] = node.expanded; });\n        return result;\n    };\n    ClientSideRowModel.prototype.getCopyOfNodesMap = function () {\n        return this.nodeManager.getCopyOfNodesMap();\n    };\n    ClientSideRowModel.prototype.getRowNode = function (id) {\n        return this.nodeManager.getRowNode(id);\n    };\n    // rows: the rows to put into the model\n    ClientSideRowModel.prototype.setRowData = function (rowData) {\n        // no need to invalidate cache, as the cache is stored on the rowNode,\n        // so new rowNodes means the cache is wiped anyway.\n        // remember group state, so we can expand groups that should be expanded\n        var groupState = this.getGroupState();\n        this.nodeManager.setRowData(rowData);\n        // this event kicks off:\n        // - clears selection\n        // - updates filters\n        // - shows 'no rows' overlay if needed\n        var rowDataChangedEvent = {\n            type: events_1.Events.EVENT_ROW_DATA_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(rowDataChangedEvent);\n        this.refreshModel({\n            step: constants_1.Constants.STEP_EVERYTHING,\n            groupState: groupState,\n            newData: true\n        });\n    };\n    ClientSideRowModel.prototype.batchUpdateRowData = function (rowDataTransaction, callback) {\n        var _this = this;\n        if (!this.rowDataTransactionBatch) {\n            this.rowDataTransactionBatch = [];\n            var waitMillis = this.gridOptionsWrapper.getBatchUpdateWaitMillis();\n            setTimeout(function () {\n                _this.executeBatchUpdateRowData();\n                _this.rowDataTransactionBatch = null;\n            }, waitMillis);\n        }\n        this.rowDataTransactionBatch.push({ rowDataTransaction: rowDataTransaction, callback: callback });\n    };\n    ClientSideRowModel.prototype.executeBatchUpdateRowData = function () {\n        var _this = this;\n        this.valueCache.onDataChanged();\n        var callbackFuncsBound = [];\n        var rowNodeTrans = [];\n        this.rowDataTransactionBatch.forEach(function (tranItem) {\n            var rowNodeTran = _this.nodeManager.updateRowData(tranItem.rowDataTransaction, null);\n            rowNodeTrans.push(rowNodeTran);\n            if (tranItem.callback) {\n                callbackFuncsBound.push(tranItem.callback.bind(rowNodeTran));\n            }\n        });\n        this.commonUpdateRowData(rowNodeTrans);\n        // do callbacks in next VM turn so it's async\n        if (callbackFuncsBound.length > 0) {\n            setTimeout(function () {\n                callbackFuncsBound.forEach(function (func) { return func(); });\n            }, 0);\n        }\n    };\n    ClientSideRowModel.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {\n        this.valueCache.onDataChanged();\n        var rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);\n        this.commonUpdateRowData([rowNodeTran], rowNodeOrder);\n        return rowNodeTran;\n    };\n    // common to updateRowData and batchUpdateRowData\n    ClientSideRowModel.prototype.commonUpdateRowData = function (rowNodeTrans, rowNodeOrder) {\n        this.refreshModel({\n            step: constants_1.Constants.STEP_EVERYTHING,\n            rowNodeTransactions: rowNodeTrans,\n            rowNodeOrder: rowNodeOrder,\n            keepRenderedRows: true,\n            animate: true,\n            keepEditingRows: true\n        });\n        var event = {\n            type: events_1.Events.EVENT_ROW_DATA_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ClientSideRowModel.prototype.doRowsToDisplay = function () {\n        this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });\n    };\n    ClientSideRowModel.prototype.onRowHeightChanged = function () {\n        this.refreshModel({ step: constants_1.Constants.STEP_MAP, keepRenderedRows: true, keepEditingRows: true });\n    };\n    ClientSideRowModel.prototype.resetRowHeights = function () {\n        this.forEachNode(function (rowNode) { return rowNode.setRowHeight(null); });\n        this.onRowHeightChanged();\n    };\n    __decorate([\n        context_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], ClientSideRowModel.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_1.Autowired('columnController'),\n        __metadata(\"design:type\", columnController_1.ColumnController)\n    ], ClientSideRowModel.prototype, \"columnController\", void 0);\n    __decorate([\n        context_1.Autowired('filterManager'),\n        __metadata(\"design:type\", filterManager_1.FilterManager)\n    ], ClientSideRowModel.prototype, \"filterManager\", void 0);\n    __decorate([\n        context_1.Autowired('$scope'),\n        __metadata(\"design:type\", Object)\n    ], ClientSideRowModel.prototype, \"$scope\", void 0);\n    __decorate([\n        context_1.Autowired('selectionController'),\n        __metadata(\"design:type\", selectionController_1.SelectionController)\n    ], ClientSideRowModel.prototype, \"selectionController\", void 0);\n    __decorate([\n        context_1.Autowired('eventService'),\n        __metadata(\"design:type\", eventService_1.EventService)\n    ], ClientSideRowModel.prototype, \"eventService\", void 0);\n    __decorate([\n        context_1.Autowired('context'),\n        __metadata(\"design:type\", context_1.Context)\n    ], ClientSideRowModel.prototype, \"context\", void 0);\n    __decorate([\n        context_1.Autowired('valueService'),\n        __metadata(\"design:type\", valueService_1.ValueService)\n    ], ClientSideRowModel.prototype, \"valueService\", void 0);\n    __decorate([\n        context_1.Autowired('valueCache'),\n        __metadata(\"design:type\", valueCache_1.ValueCache)\n    ], ClientSideRowModel.prototype, \"valueCache\", void 0);\n    __decorate([\n        context_1.Autowired('columnApi'),\n        __metadata(\"design:type\", columnApi_1.ColumnApi)\n    ], ClientSideRowModel.prototype, \"columnApi\", void 0);\n    __decorate([\n        context_1.Autowired('gridApi'),\n        __metadata(\"design:type\", gridApi_1.GridApi)\n    ], ClientSideRowModel.prototype, \"gridApi\", void 0);\n    __decorate([\n        context_1.Autowired('filterStage'),\n        __metadata(\"design:type\", Object)\n    ], ClientSideRowModel.prototype, \"filterStage\", void 0);\n    __decorate([\n        context_1.Autowired('sortStage'),\n        __metadata(\"design:type\", Object)\n    ], ClientSideRowModel.prototype, \"sortStage\", void 0);\n    __decorate([\n        context_1.Autowired('flattenStage'),\n        __metadata(\"design:type\", Object)\n    ], ClientSideRowModel.prototype, \"flattenStage\", void 0);\n    __decorate([\n        context_1.Optional('groupStage'),\n        __metadata(\"design:type\", Object)\n    ], ClientSideRowModel.prototype, \"groupStage\", void 0);\n    __decorate([\n        context_1.Optional('aggregationStage'),\n        __metadata(\"design:type\", Object)\n    ], ClientSideRowModel.prototype, \"aggregationStage\", void 0);\n    __decorate([\n        context_1.Optional('pivotStage'),\n        __metadata(\"design:type\", Object)\n    ], ClientSideRowModel.prototype, \"pivotStage\", void 0);\n    __decorate([\n        context_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], ClientSideRowModel.prototype, \"init\", null);\n    ClientSideRowModel = __decorate([\n        context_1.Bean('rowModel')\n    ], ClientSideRowModel);\n    return ClientSideRowModel;\n}());\nexports.ClientSideRowModel = ClientSideRowModel;\n",null]}