{"remainingRequest":"d:\\fframe\\workspace\\pony-web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!d:\\fframe\\workspace\\pony-web\\node_modules\\ag-grid-community\\dist\\lib\\gridPanel\\gridPanel.js","dependencies":[{"path":"d:\\fframe\\workspace\\pony-web\\node_modules\\ag-grid-community\\dist\\lib\\gridPanel\\gridPanel.js","mtime":1566387943438},{"path":"d:\\fframe\\workspace\\pony-web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1566388048828},{"path":"d:\\fframe\\workspace\\pony-web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1566387884895}],"contextDependencies":[],"result":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../utils\");\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\nvar columnController_1 = require(\"../columnController/columnController\");\nvar columnApi_1 = require(\"../columnController/columnApi\");\nvar rowRenderer_1 = require(\"../rendering/rowRenderer\");\nvar context_1 = require(\"../context/context\");\nvar eventService_1 = require(\"../eventService\");\nvar events_1 = require(\"../events\");\nvar dragService_1 = require(\"../dragAndDrop/dragService\");\nvar constants_1 = require(\"../constants\");\nvar selectionController_1 = require(\"../selectionController\");\nvar csvCreator_1 = require(\"../exporter/csvCreator\");\nvar mouseEventService_1 = require(\"./mouseEventService\");\nvar focusedCellController_1 = require(\"../focusedCellController\");\nvar scrollVisibleService_1 = require(\"./scrollVisibleService\");\nvar rowContainerComponent_1 = require(\"../rendering/rowContainerComponent\");\nvar paginationProxy_1 = require(\"../rowModels/paginationProxy\");\nvar popupEditorWrapper_1 = require(\"../rendering/cellEditors/popupEditorWrapper\");\nvar alignedGridsService_1 = require(\"../alignedGridsService\");\nvar pinnedRowModel_1 = require(\"../rowModels/pinnedRowModel\");\nvar gridApi_1 = require(\"../gridApi\");\nvar animationFrameService_1 = require(\"../misc/animationFrameService\");\nvar rowComp_1 = require(\"../rendering/rowComp\");\nvar navigationService_1 = require(\"./navigationService\");\nvar valueService_1 = require(\"../valueService/valueService\");\nvar touchListener_1 = require(\"../widgets/touchListener\");\nvar componentRecipes_1 = require(\"../components/framework/componentRecipes\");\nvar dragAndDropService_1 = require(\"../dragAndDrop/dragAndDropService\");\nvar rowDragFeature_1 = require(\"./rowDragFeature\");\nvar heightScaler_1 = require(\"../rendering/heightScaler\");\nvar component_1 = require(\"../widgets/component\");\nvar autoHeightCalculator_1 = require(\"../rendering/autoHeightCalculator\");\nvar columnAnimationService_1 = require(\"../rendering/columnAnimationService\");\nvar autoWidthCalculator_1 = require(\"../rendering/autoWidthCalculator\");\nvar beans_1 = require(\"../rendering/beans\");\nvar componentAnnotations_1 = require(\"../widgets/componentAnnotations\");\nvar headerRootComp_1 = require(\"../headerRendering/headerRootComp\");\nvar resizeObserverService_1 = require(\"../misc/resizeObserverService\");\n// in the html below, it is important that there are no white space between some of the divs, as if there is white space,\n// it won't render correctly in safari, as safari renders white space as a gap\nvar GRID_PANEL_NORMAL_TEMPLATE = \"<div class=\\\"ag-root ag-font-style\\\" role=\\\"grid\\\" unselectable=\\\"on\\\">\\n        <ag-header-root ref=\\\"headerRoot\\\" unselectable=\\\"on\\\"></ag-header-root>\\n        <div class=\\\"ag-floating-top\\\" ref=\\\"eTop\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n            <div class=\\\"ag-pinned-left-floating-top\\\" ref=\\\"eLeftTop\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            <div class=\\\"ag-floating-top-viewport\\\" ref=\\\"eTopViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-floating-top-container\\\" ref=\\\"eTopContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            </div>\\n            <div class=\\\"ag-pinned-right-floating-top\\\" ref=\\\"eRightTop\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            <div class=\\\"ag-floating-top-full-width-container\\\" ref=\\\"eTopFullWidthContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n        </div>\\n        <div class=\\\"ag-body\\\" ref=\\\"eBody\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n            <div class=\\\"ag-pinned-left-cols-viewport-wrapper\\\" ref=\\\"eLeftViewportWrapper\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-pinned-left-cols-viewport\\\" ref=\\\"eLeftViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                    <div class=\\\"ag-pinned-left-cols-container\\\" ref=\\\"eLeftContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n                </div>\\n            </div>\\n            <div class=\\\"ag-body-viewport-wrapper\\\" ref=\\\"eBodyViewportWrapper\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-body-viewport\\\" ref=\\\"eBodyViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                    <div class=\\\"ag-body-container\\\" ref=\\\"eBodyContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n                </div>\\n            </div>\\n            <div class=\\\"ag-pinned-right-cols-viewport-wrapper\\\" ref=\\\"eRightViewportWrapper\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-pinned-right-cols-viewport\\\" ref=\\\"eRightViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                    <div class=\\\"ag-pinned-right-cols-container\\\" ref=\\\"eRightContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n                </div>\\n            </div>\\n            <div class=\\\"ag-full-width-viewport-wrapper\\\" ref=\\\"eFullWidthViewportWrapper\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-full-width-viewport\\\" ref=\\\"eFullWidthViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                    <div class=\\\"ag-full-width-container\\\" ref=\\\"eFullWidthContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n                </div>\\n            </div>\\n        </div>\\n        <div class=\\\"ag-floating-bottom\\\" ref=\\\"eBottom\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n            <div class=\\\"ag-pinned-left-floating-bottom\\\" ref=\\\"eLeftBottom\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            <div class=\\\"ag-floating-bottom-viewport\\\" ref=\\\"eBottomViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-floating-bottom-container\\\" ref=\\\"eBottomContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            </div>\\n            <div class=\\\"ag-pinned-right-floating-bottom\\\" ref=\\\"eRightBottom\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            <div class=\\\"ag-floating-bottom-full-width-container\\\" ref=\\\"eBottomFullWidthContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n        </div>\\n        <div class=\\\"ag-overlay\\\" ref=\\\"eOverlay\\\"></div>\\n    </div>\";\nvar GridPanel = /*@__PURE__*/ (function (_super) {\n    __extends(GridPanel, _super);\n    function GridPanel() {\n        var _this = _super.call(this, GRID_PANEL_NORMAL_TEMPLATE) || this;\n        _this.scrollLeft = -1;\n        _this.nextScrollLeft = -1;\n        _this.scrollTop = -1;\n        _this.nextScrollTop = -1;\n        _this.verticalRedrawNeeded = false;\n        _this.recentScrolls = {};\n        return _this;\n    }\n    GridPanel.prototype.getVScrollPosition = function () {\n        var result = {\n            top: this.eBodyViewport.scrollTop,\n            bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight\n        };\n        return result;\n    };\n    // used by range controller\n    GridPanel.prototype.getHScrollPosition = function () {\n        var result = {\n            left: this.eBodyViewport.scrollLeft,\n            right: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetWidth\n        };\n        return result;\n    };\n    // we override this, as the base class is missing the annotation\n    GridPanel.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    GridPanel.prototype.onRowDataChanged = function () {\n        this.showOrHideOverlay();\n    };\n    GridPanel.prototype.showOrHideOverlay = function () {\n        if (this.paginationProxy.isEmpty() && !this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {\n            this.showNoRowsOverlay();\n        }\n        else {\n            this.hideOverlay();\n        }\n    };\n    GridPanel.prototype.onNewColumnsLoaded = function () {\n        // hide overlay if columns and rows exist, this can happen if columns are loaded after data.\n        // this problem exists before of the race condition between the services (column controller in this case)\n        // and the view (grid panel). if the model beans were all initialised first, and then the view beans second,\n        // this race condition would not happen.\n        if (this.columnController.isReady() && !this.paginationProxy.isEmpty()) {\n            this.hideOverlay();\n        }\n    };\n    GridPanel.prototype.init = function () {\n        this.instantiate(this.context);\n        this.scrollWidth = this.gridOptionsWrapper.getScrollbarWidth();\n        this.enableRtl = this.gridOptionsWrapper.isEnableRtl();\n        this.useAnimationFrame = !this.gridOptionsWrapper.isSuppressAnimationFrame();\n        this.printLayout = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_PRINT;\n        // if the browser is Windows based, then the scrollbars take up space, and we clip by\n        // the width of the scrollbar. however if the scroll bars do not take up space (iOS)\n        // then they overlay on top of the div, so we clip some extra blank space instead.\n        this.scrollClipWidth = this.scrollWidth > 0 ? this.scrollWidth : 20;\n        // all of these element have different CSS when layout changes\n        this.gridOptionsWrapper.addLayoutElement(this.getGui());\n        this.gridOptionsWrapper.addLayoutElement(this.eBody);\n        this.gridOptionsWrapper.addLayoutElement(this.eBodyViewport);\n        this.gridOptionsWrapper.addLayoutElement(this.eTopViewport);\n        this.gridOptionsWrapper.addLayoutElement(this.eBodyContainer);\n        this.gridOptionsWrapper.addLayoutElement(this.eBodyViewportWrapper);\n        this.suppressScrollOnFloatingRow();\n        this.setupRowAnimationCssClass();\n        this.buildRowContainerComponents();\n        this.addEventListeners();\n        this.addDragListeners();\n        this.addScrollListener();\n        if (this.gridOptionsWrapper.isSuppressHorizontalScroll()) {\n            this.eBodyViewport.style.overflowX = 'hidden';\n        }\n        this.setupOverlay();\n        if (this.gridOptionsWrapper.isRowModelDefault() && !this.gridOptionsWrapper.getRowData()) {\n            this.showLoadingOverlay();\n        }\n        this.setPinnedContainersVisible();\n        this.setBodyAndHeaderHeights();\n        this.disableBrowserDragging();\n        this.addShortcutKeyListeners();\n        this.addMouseListeners();\n        this.addKeyboardEvents();\n        this.addBodyViewportListener();\n        this.addStopEditingWhenGridLosesFocus();\n        this.mockContextMenuForIPad();\n        this.addRowDragListener();\n        if (this.$scope) {\n            this.addAngularApplyCheck();\n        }\n        this.onDisplayedColumnsWidthChanged();\n        // this.addWindowResizeListener();\n        this.gridApi.registerGridComp(this);\n        this.alignedGridsService.registerGridComp(this);\n        this.headerRootComp.registerGridComp(this);\n        this.animationFrameService.registerGridComp(this);\n        this.navigationService.registerGridComp(this);\n        this.heightScaler.registerGridComp(this);\n        this.autoHeightCalculator.registerGridComp(this);\n        this.columnAnimationService.registerGridComp(this);\n        this.autoWidthCalculator.registerGridComp(this);\n        this.paginationAutoPageSizeService.registerGridComp(this);\n        this.beans.registerGridComp(this);\n        this.rowRenderer.registerGridComp(this);\n        if (this.rangeController) {\n            this.rangeController.registerGridComp(this);\n        }\n        var unsubscribeFromResize = this.resizeObserverService.observeResize(this.eBodyViewport, this.onBodyViewportResized.bind(this));\n        this.addDestroyFunc(function () { return unsubscribeFromResize(); });\n    };\n    GridPanel.prototype.onDomLayoutChanged = function () {\n        var newPrintLayout = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_PRINT;\n        if (this.printLayout !== newPrintLayout) {\n            this.printLayout = newPrintLayout;\n            this.setWidthsOfContainers();\n            // pinned containers are always hidden for print layout\n            this.setPinnedContainersVisible();\n            // in case we have margins for hiding the scroll on body, this takes them out\n            this.hideVerticalScrollOnCenter();\n        }\n    };\n    GridPanel.prototype.onBodyViewportResized = function () {\n        this.checkViewportAndScrolls();\n    };\n    // used by ColumnAnimationService\n    GridPanel.prototype.setColumnMovingCss = function (moving) {\n        this.addOrRemoveCssClass('ag-column-moving', moving);\n    };\n    GridPanel.prototype.setupOverlay = function () {\n        this.overlayWrapper = this.componentRecipes.newOverlayWrapperComponent();\n        this.eOverlay = this.queryForHtmlElement('[ref=\"eOverlay\"]');\n        this.overlayWrapper.hideOverlay(this.eOverlay);\n    };\n    GridPanel.prototype.addRowDragListener = function () {\n        var rowDragFeature = new rowDragFeature_1.RowDragFeature(this.eBody, this);\n        this.context.wireBean(rowDragFeature);\n        this.dragAndDropService.addDropTarget(rowDragFeature);\n    };\n    GridPanel.prototype.addStopEditingWhenGridLosesFocus = function () {\n        var _this = this;\n        if (!this.gridOptionsWrapper.isStopEditingWhenGridLosesFocus()) {\n            return;\n        }\n        var focusOutListener = function (event) {\n            // this is the element the focus is moving to\n            var elementWithFocus = event.relatedTarget;\n            // see if the element the focus is going to is part of the grid\n            var clickInsideGrid = false;\n            var pointer = elementWithFocus;\n            while (utils_1.Utils.exists(pointer) && !clickInsideGrid) {\n                var isPopup = !!_this.gridOptionsWrapper.getDomData(pointer, popupEditorWrapper_1.PopupEditorWrapper.DOM_KEY_POPUP_EDITOR_WRAPPER);\n                var isBody = _this.eBody === pointer || _this.eBottom === pointer || _this.eTop === pointer;\n                clickInsideGrid = isPopup || isBody;\n                pointer = pointer.parentNode;\n            }\n            if (!clickInsideGrid) {\n                _this.rowRenderer.stopEditing();\n            }\n        };\n        this.addDestroyableEventListener(this.eBody, 'focusout', focusOutListener);\n        this.addDestroyableEventListener(this.eTop, 'focusout', focusOutListener);\n        this.addDestroyableEventListener(this.eBottom, 'focusout', focusOutListener);\n    };\n    GridPanel.prototype.addAngularApplyCheck = function () {\n        var _this = this;\n        // this makes sure if we queue up requests, we only execute oe\n        var applyTriggered = false;\n        var listener = function () {\n            // only need to do one apply at a time\n            if (applyTriggered) {\n                return;\n            }\n            applyTriggered = true; // mark 'need apply' to true\n            setTimeout(function () {\n                applyTriggered = false;\n                _this.$scope.$apply();\n            }, 0);\n        };\n        // these are the events we need to do an apply after - these are the ones that can end up\n        // with columns added or removed\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, listener);\n    };\n    // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)\n    // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.\n    GridPanel.prototype.disableBrowserDragging = function () {\n        this.addGuiEventListener('dragstart', function (event) {\n            if (event.target instanceof HTMLImageElement) {\n                event.preventDefault();\n                return false;\n            }\n        });\n    };\n    GridPanel.prototype.addEventListeners = function () {\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PINNED_ROW_DATA_CHANGED, this.setBodyAndHeaderHeights.bind(this));\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_ROW_DATA_CHANGED, this.onRowDataChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_ROW_DATA_UPDATED, this.onRowDataChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));\n        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_GROUP_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_FLOATING_FILTERS_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n    };\n    GridPanel.prototype.addDragListeners = function () {\n        var _this = this;\n        if (!this.gridOptionsWrapper.isEnableRangeSelection() // no range selection if no property\n            || utils_1.Utils.missing(this.rangeController)) {\n            return;\n        }\n        var containers = [this.eLeftContainer, this.eRightContainer, this.eBodyContainer,\n            this.eTop, this.eBottom];\n        containers.forEach(function (container) {\n            var params = {\n                eElement: container,\n                onDragStart: _this.rangeController.onDragStart.bind(_this.rangeController),\n                onDragStop: _this.rangeController.onDragStop.bind(_this.rangeController),\n                onDragging: _this.rangeController.onDragging.bind(_this.rangeController),\n                // for range selection by dragging the mouse, we want to ignore the event if shift key is pressed,\n                // as shift key click is another type of range selection\n                skipMouseEvent: function (mouseEvent) { return mouseEvent.shiftKey; }\n            };\n            _this.dragService.addDragSource(params);\n            _this.addDestroyFunc(function () { return _this.dragService.removeDragSource(params); });\n        });\n    };\n    GridPanel.prototype.addMouseListeners = function () {\n        var _this = this;\n        var eventNames = ['click', 'mousedown', 'dblclick', 'contextmenu', 'mouseover', 'mouseout'];\n        eventNames.forEach(function (eventName) {\n            var listener = _this.processMouseEvent.bind(_this, eventName);\n            _this.eAllCellContainers.forEach(function (container) {\n                return _this.addDestroyableEventListener(container, eventName, listener);\n            });\n        });\n    };\n    GridPanel.prototype.addKeyboardEvents = function () {\n        var _this = this;\n        var eventNames = ['keydown', 'keypress'];\n        eventNames.forEach(function (eventName) {\n            var listener = _this.processKeyboardEvent.bind(_this, eventName);\n            _this.eAllCellContainers.forEach(function (container) {\n                _this.addDestroyableEventListener(container, eventName, listener);\n            });\n        });\n    };\n    GridPanel.prototype.addBodyViewportListener = function () {\n        var _this = this;\n        // we want to listen for clicks directly on the eBodyViewport, so the user has a way of showing\n        // the context menu if no rows are displayed, or user simply clicks outside of a cell\n        var listener = function (mouseEvent) {\n            var target = utils_1.Utils.getTarget(mouseEvent);\n            if (target === _this.eBodyViewport || target === _this.eLeftViewport || target === _this.eRightViewport) {\n                // show it\n                _this.onContextMenu(mouseEvent, null, null, null, null);\n                _this.preventDefaultOnContextMenu(mouseEvent);\n            }\n        };\n        //For some reason listening only to this.eBody doesnt work... Maybe because the event is consumed somewhere else?\n        //In any case, not expending much time on this, if anyome comes accross this and knows how to make this work with\n        //one listener please go ahead and change it...\n        this.addDestroyableEventListener(this.eBodyViewport, 'contextmenu', listener);\n        this.addDestroyableEventListener(this.eRightViewport, 'contextmenu', listener);\n        this.addDestroyableEventListener(this.eLeftViewport, 'contextmenu', listener);\n    };\n    // + rangeController\n    GridPanel.prototype.getBodyClientRect = function () {\n        if (this.eBody) {\n            return this.eBody.getBoundingClientRect();\n        }\n    };\n    GridPanel.prototype.getRowForEvent = function (event) {\n        var sourceElement = utils_1.Utils.getTarget(event);\n        while (sourceElement) {\n            var renderedRow = this.gridOptionsWrapper.getDomData(sourceElement, rowComp_1.RowComp.DOM_DATA_KEY_RENDERED_ROW);\n            if (renderedRow) {\n                return renderedRow;\n            }\n            sourceElement = sourceElement.parentElement;\n        }\n        return null;\n    };\n    GridPanel.prototype.processKeyboardEvent = function (eventName, keyboardEvent) {\n        var renderedCell = this.mouseEventService.getRenderedCellForEvent(keyboardEvent);\n        if (!renderedCell) {\n            return;\n        }\n        switch (eventName) {\n            case 'keydown':\n                // first see if it's a scroll key, page up / down, home / end etc\n                var wasScrollKey = this.navigationService.handlePageScrollingKey(keyboardEvent);\n                // if not a scroll key, then we pass onto cell\n                if (!wasScrollKey) {\n                    renderedCell.onKeyDown(keyboardEvent);\n                }\n                break;\n            case 'keypress':\n                renderedCell.onKeyPress(keyboardEvent);\n                break;\n        }\n    };\n    // gets called by rowRenderer when new data loaded, as it will want to scroll to the top\n    GridPanel.prototype.scrollToTop = function () {\n        this.eBodyViewport.scrollTop = 0;\n    };\n    GridPanel.prototype.processMouseEvent = function (eventName, mouseEvent) {\n        if (!this.mouseEventService.isEventFromThisGrid(mouseEvent)) {\n            return;\n        }\n        if (utils_1.Utils.isStopPropagationForAgGrid(mouseEvent)) {\n            return;\n        }\n        var rowComp = this.getRowForEvent(mouseEvent);\n        var cellComp = this.mouseEventService.getRenderedCellForEvent(mouseEvent);\n        if (eventName === \"contextmenu\") {\n            this.handleContextMenuMouseEvent(mouseEvent, null, rowComp, cellComp);\n        }\n        else {\n            if (cellComp) {\n                cellComp.onMouseEvent(eventName, mouseEvent);\n            }\n            if (rowComp) {\n                rowComp.onMouseEvent(eventName, mouseEvent);\n            }\n        }\n        this.preventDefaultOnContextMenu(mouseEvent);\n    };\n    GridPanel.prototype.mockContextMenuForIPad = function () {\n        var _this = this;\n        // we do NOT want this when not in ipad, otherwise we will be doing\n        if (!utils_1.Utils.isUserAgentIPad()) {\n            return;\n        }\n        this.eAllCellContainers.forEach(function (container) {\n            var touchListener = new touchListener_1.TouchListener(container);\n            var longTapListener = function (event) {\n                var rowComp = _this.getRowForEvent(event.touchEvent);\n                var cellComp = _this.mouseEventService.getRenderedCellForEvent(event.touchEvent);\n                _this.handleContextMenuMouseEvent(null, event.touchEvent, rowComp, cellComp);\n            };\n            _this.addDestroyableEventListener(touchListener, touchListener_1.TouchListener.EVENT_LONG_TAP, longTapListener);\n            _this.addDestroyFunc(function () { return touchListener.destroy(); });\n        });\n    };\n    GridPanel.prototype.handleContextMenuMouseEvent = function (mouseEvent, touchEvent, rowComp, cellComp) {\n        var rowNode = rowComp ? rowComp.getRowNode() : null;\n        var column = cellComp ? cellComp.getColumn() : null;\n        var value = null;\n        if (column) {\n            var event_1 = mouseEvent ? mouseEvent : touchEvent;\n            cellComp.dispatchCellContextMenuEvent(event_1);\n            value = this.valueService.getValue(column, rowNode);\n        }\n        this.onContextMenu(mouseEvent, touchEvent, rowNode, column, value);\n    };\n    GridPanel.prototype.onContextMenu = function (mouseEvent, touchEvent, rowNode, column, value) {\n        // to allow us to debug in chrome, we ignore the event if ctrl is pressed.\n        // not everyone wants this, so first 'if' below allows to turn this hack off.\n        if (!this.gridOptionsWrapper.isAllowContextMenuWithControlKey()) {\n            // then do the check\n            if (mouseEvent && (mouseEvent.ctrlKey || mouseEvent.metaKey)) {\n                return;\n            }\n        }\n        if (this.contextMenuFactory && !this.gridOptionsWrapper.isSuppressContextMenu()) {\n            var eventOrTouch = mouseEvent ? mouseEvent : touchEvent.touches[0];\n            this.contextMenuFactory.showMenu(rowNode, column, value, eventOrTouch);\n            var event_2 = mouseEvent ? mouseEvent : touchEvent;\n            event_2.preventDefault();\n        }\n    };\n    GridPanel.prototype.preventDefaultOnContextMenu = function (mouseEvent) {\n        // if we don't do this, then middle click will never result in a 'click' event, as 'mousedown'\n        // will be consumed by the browser to mean 'scroll' (as you can scroll with the middle mouse\n        // button in the browser). so this property allows the user to receive middle button clicks if\n        // they want.\n        if (this.gridOptionsWrapper.isSuppressMiddleClickScrolls() && mouseEvent.which === 2) {\n            mouseEvent.preventDefault();\n        }\n    };\n    GridPanel.prototype.addShortcutKeyListeners = function () {\n        var _this = this;\n        this.eAllCellContainers.forEach(function (container) {\n            _this.addDestroyableEventListener(container, 'keydown', function (event) {\n                // if the cell the event came from is editing, then we do not\n                // want to do the default shortcut keys, otherwise the editor\n                // (eg a text field) would not be able to do the normal cut/copy/paste\n                var renderedCell = _this.mouseEventService.getRenderedCellForEvent(event);\n                if (renderedCell && renderedCell.isEditing()) {\n                    return;\n                }\n                // for copy / paste, we don't want to execute when the event\n                // was from a child grid (happens in master detail)\n                if (!_this.mouseEventService.isEventFromThisGrid(event)) {\n                    return;\n                }\n                if (event.ctrlKey || event.metaKey) {\n                    switch (event.which) {\n                        case constants_1.Constants.KEY_A:\n                            return _this.onCtrlAndA(event);\n                        case constants_1.Constants.KEY_C:\n                            return _this.onCtrlAndC(event);\n                        case constants_1.Constants.KEY_V:\n                            return _this.onCtrlAndV(event);\n                        case constants_1.Constants.KEY_D:\n                            return _this.onCtrlAndD(event);\n                    }\n                }\n            });\n        });\n    };\n    GridPanel.prototype.onCtrlAndA = function (event) {\n        if (this.rangeController && this.paginationProxy.isRowsToRender()) {\n            var rowEnd = void 0;\n            var floatingStart = void 0;\n            var floatingEnd = void 0;\n            if (this.pinnedRowModel.isEmpty(constants_1.Constants.PINNED_TOP)) {\n                floatingStart = null;\n            }\n            else {\n                floatingStart = constants_1.Constants.PINNED_TOP;\n            }\n            if (this.pinnedRowModel.isEmpty(constants_1.Constants.PINNED_BOTTOM)) {\n                floatingEnd = null;\n                rowEnd = this.paginationProxy.getTotalRowCount() - 1;\n            }\n            else {\n                floatingEnd = constants_1.Constants.PINNED_BOTTOM;\n                rowEnd = this.pinnedRowModel.getPinnedBottomRowData().length - 1;\n            }\n            var allDisplayedColumns = this.columnController.getAllDisplayedColumns();\n            if (utils_1.Utils.missingOrEmpty(allDisplayedColumns)) {\n                return;\n            }\n            this.rangeController.setRange({\n                rowStart: 0,\n                floatingStart: floatingStart,\n                rowEnd: rowEnd,\n                floatingEnd: floatingEnd,\n                columnStart: allDisplayedColumns[0],\n                columnEnd: allDisplayedColumns[allDisplayedColumns.length - 1]\n            });\n        }\n        event.preventDefault();\n        return false;\n    };\n    GridPanel.prototype.onCtrlAndC = function (event) {\n        if (!this.clipboardService) {\n            return;\n        }\n        var focusedCell = this.focusedCellController.getFocusedCell();\n        this.clipboardService.copyToClipboard();\n        event.preventDefault();\n        // the copy operation results in loosing focus on the cell,\n        // because of the trickery the copy logic uses with a temporary\n        // widget. so we set it back again.\n        if (focusedCell) {\n            this.focusedCellController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.floating, true);\n        }\n        return false;\n    };\n    GridPanel.prototype.onCtrlAndV = function (event) {\n        if (!this.enterprise) {\n            return;\n        }\n        if (this.gridOptionsWrapper.isSuppressClipboardPaste()) {\n            return;\n        }\n        this.clipboardService.pasteFromClipboard();\n        return false;\n    };\n    GridPanel.prototype.onCtrlAndD = function (event) {\n        if (!this.enterprise) {\n            return;\n        }\n        this.clipboardService.copyRangeDown();\n        event.preventDefault();\n        return false;\n    };\n    // Valid values for position are bottom, middle and top\n    // position should be {'top','middle','bottom', or undefined/null}.\n    // if undefined/null, then the grid will to the minimal amount of scrolling,\n    // eg if grid needs to scroll up, it scrolls until row is on top,\n    //    if grid needs to scroll down, it scrolls until row is on bottom,\n    //    if row is already in view, grid does not scroll\n    GridPanel.prototype.ensureIndexVisible = function (index, position) {\n        // if for print or auto height, everything is always visible\n        if (this.printLayout) {\n            return;\n        }\n        var rowCount = this.paginationProxy.getTotalRowCount();\n        if (typeof index !== 'number' || index < 0 || index >= rowCount) {\n            console.warn('invalid row index for ensureIndexVisible: ' + index);\n            return;\n        }\n        this.paginationProxy.goToPageWithIndex(index);\n        var rowNode = this.paginationProxy.getRow(index);\n        var paginationOffset = this.paginationProxy.getPixelOffset();\n        var rowTopPixel = rowNode.rowTop - paginationOffset;\n        var rowBottomPixel = rowTopPixel + rowNode.rowHeight;\n        var scrollPosition = this.getVScrollPosition();\n        var heightOffset = this.heightScaler.getOffset();\n        var vScrollTop = scrollPosition.top + heightOffset;\n        var vScrollBottom = scrollPosition.bottom + heightOffset;\n        if (this.isHorizontalScrollShowing()) {\n            vScrollBottom -= this.scrollWidth;\n        }\n        var viewportHeight = vScrollBottom - vScrollTop;\n        var newScrollPosition = null;\n        // work out the pixels for top, middle and bottom up front,\n        // make the if/else below easier to read\n        var pxTop = this.heightScaler.getScrollPositionForPixel(rowTopPixel);\n        var pxBottom = this.heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);\n        var pxMiddle = (pxTop + pxBottom) / 2;\n        // make sure if middle, the row is not outside the top of the grid\n        if (pxMiddle > rowTopPixel) {\n            pxMiddle = rowTopPixel;\n        }\n        var rowBelowViewport = vScrollTop > rowTopPixel;\n        var rowAboveViewport = vScrollBottom < rowBottomPixel;\n        if (position === 'top') {\n            newScrollPosition = pxTop;\n        }\n        else if (position === 'bottom') {\n            newScrollPosition = pxBottom;\n        }\n        else if (position === 'middle') {\n            newScrollPosition = pxMiddle;\n        }\n        else if (rowBelowViewport) {\n            // if row is before, scroll up with row at top\n            newScrollPosition = pxTop;\n        }\n        else if (rowAboveViewport) {\n            // if row is below, scroll down with row at bottom\n            newScrollPosition = pxBottom;\n        }\n        if (newScrollPosition !== null) {\n            this.eBodyViewport.scrollTop = newScrollPosition;\n            this.rowRenderer.redrawAfterScroll();\n        }\n        // so when we return back to user, the cells have rendered\n        this.animationFrameService.flushAllFrames();\n    };\n    // + moveColumnController\n    GridPanel.prototype.getCenterWidth = function () {\n        return this.eBodyViewport.clientWidth;\n    };\n    GridPanel.prototype.isHorizontalScrollShowing = function () {\n        return utils_1.Utils.isHorizontalScrollShowing(this.eBodyViewport);\n    };\n    GridPanel.prototype.isVerticalScrollShowing = function () {\n        return utils_1.Utils.isVerticalScrollShowing(this.eBodyViewport);\n    };\n    // gets called every time the viewport size changes. we use this to check visibility of scrollbars\n    // in the grid panel, and also to check size and position of viewport for row and column virtualisation.\n    GridPanel.prototype.checkViewportAndScrolls = function () {\n        // results in updating anything that depends on scroll showing\n        this.updateScrollVisibleService();\n        // fires event if height changes, used by PaginationService, HeightScalerService, RowRenderer\n        this.checkBodyHeight();\n        // check for virtual columns for ColumnController\n        this.onHorizontalViewportChanged();\n        this.setPinnedLeftWidth();\n        this.setPinnedRightWidth();\n        this.setBottomPaddingOnPinned();\n        this.hideVerticalScrollOnCenter();\n        this.hideFullWidthViewportScrollbars();\n    };\n    GridPanel.prototype.updateScrollVisibleService = function () {\n        var params = {\n            bodyHorizontalScrollShowing: false,\n            leftVerticalScrollShowing: false,\n            rightVerticalScrollShowing: false\n        };\n        if (this.enableRtl && this.columnController.isPinningLeft()) {\n            params.leftVerticalScrollShowing = utils_1.Utils.isVerticalScrollShowing(this.eLeftViewport);\n        }\n        if (!this.enableRtl && this.columnController.isPinningRight()) {\n            params.rightVerticalScrollShowing = utils_1.Utils.isVerticalScrollShowing(this.eRightViewport);\n        }\n        params.bodyHorizontalScrollShowing = this.isHorizontalScrollShowing();\n        this.scrollVisibleService.setScrollsVisible(params);\n    };\n    // the pinned container needs extra space at the bottom, some blank space, otherwise when\n    // vertically scrolled all the way down, the last row will be hidden behind the scrolls.\n    // this extra padding allows the last row to be lifted above the bottom scrollbar.\n    GridPanel.prototype.setBottomPaddingOnPinned = function () {\n        // no need for padding if the scrollbars are not taking up any space\n        if (this.scrollWidth <= 0) {\n            return;\n        }\n        if (this.isHorizontalScrollShowing()) {\n            this.eRightContainer.style.marginBottom = this.scrollWidth + 'px';\n            this.eLeftContainer.style.marginBottom = this.scrollWidth + 'px';\n        }\n        else {\n            this.eRightContainer.style.marginBottom = '';\n            this.eLeftContainer.style.marginBottom = '';\n        }\n    };\n    GridPanel.prototype.hideFullWidthViewportScrollbars = function () {\n        // if browser does not have scrollbars that take up space (eg iOS) then we don't need\n        // to adjust the sizes of the container for scrollbars\n        // if (this.scrollWidth <= 0) { return; }\n        var scrollWidthPx = this.scrollClipWidth > 0 ? this.scrollWidth + 'px' : '';\n        // if horizontal scroll is showing, we add padding to bottom so\n        // fullWidth container is not spreading over the scroll\n        this.eFullWidthViewportWrapper.style.paddingBottom = this.isHorizontalScrollShowing() ? scrollWidthPx : '';\n        // if vertical scroll is showing on full width viewport, then we clip it away, otherwise\n        // it competes with the main vertical scroll. this is done by getting the viewport to be\n        // bigger than the wrapper, the wrapper then ends up clipping the viewport.\n        var takeOutVScroll = this.isVerticalScrollShowing();\n        if (this.enableRtl) {\n            this.eFullWidthViewportWrapper.style.marginLeft = takeOutVScroll ? scrollWidthPx : '';\n            this.eFullWidthViewport.style.marginLeft = takeOutVScroll ? ('-' + scrollWidthPx) : '';\n        }\n        else {\n            this.eFullWidthViewportWrapper.style.width = takeOutVScroll ? \"calc(100% - \" + scrollWidthPx + \")\" : '';\n            this.eFullWidthViewport.style.width = takeOutVScroll ? \"calc(100% + \" + scrollWidthPx + \")\" : '';\n        }\n    };\n    GridPanel.prototype.ensureColumnVisible = function (key) {\n        var column = this.columnController.getGridColumn(key);\n        if (!column) {\n            return;\n        }\n        if (column.isPinned()) {\n            console.warn('calling ensureIndexVisible on a ' + column.getPinned() + ' pinned column doesn\\'t make sense for column ' + column.getColId());\n            return;\n        }\n        if (!this.columnController.isColumnDisplayed(column)) {\n            console.warn('column is not currently visible');\n            return;\n        }\n        var colLeftPixel = column.getLeft();\n        var colRightPixel = colLeftPixel + column.getActualWidth();\n        var viewportWidth = this.eBodyViewport.clientWidth;\n        var scrollPosition = this.getBodyViewportScrollLeft();\n        var bodyWidth = this.columnController.getBodyContainerWidth();\n        var viewportLeftPixel;\n        var viewportRightPixel;\n        // the logic of working out left and right viewport px is both here and in the ColumnController,\n        // need to refactor it out to one place\n        if (this.enableRtl) {\n            viewportLeftPixel = bodyWidth - scrollPosition - viewportWidth;\n            viewportRightPixel = bodyWidth - scrollPosition;\n        }\n        else {\n            viewportLeftPixel = scrollPosition;\n            viewportRightPixel = viewportWidth + scrollPosition;\n        }\n        var viewportScrolledPastCol = viewportLeftPixel > colLeftPixel;\n        var viewportScrolledBeforeCol = viewportRightPixel < colRightPixel;\n        var colToSmallForViewport = viewportWidth < column.getActualWidth();\n        var alignColToLeft = viewportScrolledPastCol || colToSmallForViewport;\n        var alignColToRight = viewportScrolledBeforeCol;\n        var newScrollPosition = this.getBodyViewportScrollLeft();\n        if (alignColToLeft || alignColToRight) {\n            if (this.enableRtl) {\n                newScrollPosition = alignColToLeft ? (bodyWidth - viewportWidth - colLeftPixel) : (bodyWidth - colRightPixel);\n            }\n            else {\n                newScrollPosition = alignColToLeft ? colLeftPixel : (colRightPixel - viewportWidth);\n            }\n            this.setBodyViewportScrollLeft(newScrollPosition);\n        }\n        else {\n            // otherwise, col is already in view, so do nothing\n        }\n        // this will happen anyway, as the move will cause a 'scroll' event on the body, however\n        // it is possible that the ensureColumnVisible method is called from within ag-Grid and\n        // the caller will need to have the columns rendered to continue, which will be before\n        // the event has been worked on (which is the case for cell navigation).\n        this.onHorizontalViewportChanged();\n        // so when we return back to user, the cells have rendered\n        this.animationFrameService.flushAllFrames();\n    };\n    GridPanel.prototype.showLoadingOverlay = function () {\n        if (!this.gridOptionsWrapper.isSuppressLoadingOverlay()) {\n            this.overlayWrapper.showLoadingOverlay(this.eOverlay);\n        }\n    };\n    GridPanel.prototype.showNoRowsOverlay = function () {\n        if (!this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {\n            this.overlayWrapper.showNoRowsOverlay(this.eOverlay);\n        }\n    };\n    GridPanel.prototype.hideOverlay = function () {\n        this.overlayWrapper.hideOverlay(this.eOverlay);\n    };\n    GridPanel.prototype.getWidthForSizeColsToFit = function () {\n        var availableWidth = this.eBody.clientWidth;\n        // if pinning right, then the scroll bar can show, however for some reason\n        // it overlays the grid and doesn't take space. so we are only interested\n        // in the body scroll showing.\n        var removeVerticalScrollWidth = this.isVerticalScrollShowing();\n        if (removeVerticalScrollWidth) {\n            availableWidth -= this.scrollWidth;\n        }\n        return availableWidth;\n    };\n    // method will call itself if no available width. this covers if the grid\n    // isn't visible, but is just about to be visible.\n    GridPanel.prototype.sizeColumnsToFit = function (nextTimeout) {\n        var _this = this;\n        var availableWidth = this.getWidthForSizeColsToFit();\n        if (availableWidth > 0) {\n            this.columnController.sizeColumnsToFit(availableWidth, \"sizeColumnsToFit\");\n        }\n        else {\n            if (nextTimeout === undefined) {\n                setTimeout(function () {\n                    _this.sizeColumnsToFit(100);\n                }, 0);\n            }\n            else if (nextTimeout === 100) {\n                setTimeout(function () {\n                    _this.sizeColumnsToFit(500);\n                }, 100);\n            }\n            else if (nextTimeout === 500) {\n                setTimeout(function () {\n                    _this.sizeColumnsToFit(-1);\n                }, 500);\n            }\n            else {\n                console.warn('ag-Grid: tried to call sizeColumnsToFit() but the grid is coming back with ' +\n                    'zero width, maybe the grid is not visible yet on the screen?');\n            }\n        }\n    };\n    // used by autoWidthCalculator and autoHeightCalculator\n    GridPanel.prototype.getBodyContainer = function () {\n        return this.eBodyContainer;\n    };\n    GridPanel.prototype.getDropTargetBodyContainers = function () {\n        return [this.eBodyViewport, this.eTopViewport, this.eBottomViewport];\n    };\n    GridPanel.prototype.getDropTargetLeftContainers = function () {\n        return [this.eLeftViewport, this.eLeftBottom, this.eLeftTop];\n    };\n    GridPanel.prototype.getDropTargetRightContainers = function () {\n        return [this.eRightViewport, this.eRightBottom, this.eRightTop];\n    };\n    GridPanel.prototype.buildRowContainerComponents = function () {\n        var _this = this;\n        this.eAllCellContainers = [\n            this.eLeftContainer, this.eRightContainer, this.eBodyContainer,\n            this.eTop, this.eBottom, this.eFullWidthContainer\n        ];\n        this.rowContainerComponents = {\n            body: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eBodyContainer, eViewport: this.eBodyViewport }),\n            fullWidth: new rowContainerComponent_1.RowContainerComponent({\n                eContainer: this.eFullWidthContainer,\n                hideWhenNoChildren: true,\n                eViewport: this.eFullWidthViewport\n            }),\n            pinnedLeft: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eLeftContainer, eViewport: this.eLeftViewport }),\n            pinnedRight: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eRightContainer, eViewport: this.eRightViewport }),\n            floatingTop: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eTopContainer }),\n            floatingTopPinnedLeft: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eLeftTop }),\n            floatingTopPinnedRight: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eRightTop }),\n            floatingTopFullWidth: new rowContainerComponent_1.RowContainerComponent({\n                eContainer: this.eTopFullWidthContainer,\n                hideWhenNoChildren: true\n            }),\n            floatingBottom: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eBottomContainer }),\n            floatingBottomPinnedLeft: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eLeftBottom }),\n            floatingBottomPinnedRight: new rowContainerComponent_1.RowContainerComponent({ eContainer: this.eRightBottom }),\n            floatingBottomFullWith: new rowContainerComponent_1.RowContainerComponent({\n                eContainer: this.eBottomFullWidthContainer,\n                hideWhenNoChildren: true\n            }),\n        };\n        utils_1.Utils.iterateObject(this.rowContainerComponents, function (key, container) {\n            if (container) {\n                _this.context.wireBean(container);\n            }\n        });\n    };\n    GridPanel.prototype.setupRowAnimationCssClass = function () {\n        var _this = this;\n        var listener = function () {\n            // we don't want to use row animation if scaling, as rows jump strangely as you scroll,\n            // when scaling and doing row animation.\n            var animateRows = _this.gridOptionsWrapper.isAnimateRows() && !_this.heightScaler.isScaling();\n            utils_1.Utils.addOrRemoveCssClass(_this.eBody, 'ag-row-animation', animateRows);\n            utils_1.Utils.addOrRemoveCssClass(_this.eBody, 'ag-row-no-animation', !animateRows);\n        };\n        listener();\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_HEIGHT_SCALE_CHANGED, listener);\n    };\n    // when editing a pinned row, if the cell is half outside the scrollable area, the browser can\n    // scroll the column into view. we do not want this, the pinned sections should never scroll.\n    // so we listen to scrolls on these containers and reset the scroll if we find one.\n    GridPanel.prototype.suppressScrollOnFloatingRow = function () {\n        var _this = this;\n        var resetTopScroll = function () { return _this.eTopViewport.scrollLeft = 0; };\n        var resetBottomScroll = function () { return _this.eTopViewport.scrollLeft = 0; };\n        this.addDestroyableEventListener(this.eTopViewport, 'scroll', resetTopScroll);\n        this.addDestroyableEventListener(this.eBottomViewport, 'scroll', resetBottomScroll);\n    };\n    GridPanel.prototype.getRowContainers = function () {\n        return this.rowContainerComponents;\n    };\n    GridPanel.prototype.onDisplayedColumnsChanged = function () {\n        this.setPinnedContainersVisible();\n        this.setBodyAndHeaderHeights();\n        this.onHorizontalViewportChanged();\n    };\n    GridPanel.prototype.onDisplayedColumnsWidthChanged = function () {\n        this.setWidthsOfContainers();\n        this.onHorizontalViewportChanged();\n        if (this.enableRtl) {\n            // because RTL is all backwards, a change in the width of the row\n            // can cause a change in the scroll position, without a scroll event,\n            // because the scroll position in RTL is a function that depends on\n            // the width. to be convinced of this, take out this line, enable RTL,\n            // scroll all the way to the left and then resize a column\n            this.horizontallyScrollHeaderCenterAndFloatingCenter();\n        }\n    };\n    GridPanel.prototype.setWidthsOfContainers = function () {\n        this.setCenterWidth();\n        this.setPinnedLeftWidth();\n        this.setPinnedRightWidth();\n    };\n    GridPanel.prototype.setCenterWidth = function () {\n        var width = this.columnController.getBodyContainerWidth();\n        if (this.printLayout) {\n            var pinnedContainerWidths = this.columnController.getPinnedLeftContainerWidth()\n                + this.columnController.getPinnedRightContainerWidth();\n            width += pinnedContainerWidths;\n        }\n        var widthPx = width + 'px';\n        this.eBodyContainer.style.width = widthPx;\n        this.eBottomContainer.style.width = widthPx;\n        this.eTopContainer.style.width = widthPx;\n    };\n    GridPanel.prototype.setPinnedLeftWidth = function () {\n        var widthOfCols = this.columnController.getPinnedLeftContainerWidth();\n        var showContainers = !this.printLayout && widthOfCols > 0;\n        var eParentContainers = [this.eLeftViewportWrapper, this.eLeftTop, this.eLeftBottom];\n        eParentContainers.forEach(function (e) { return utils_1.Utils.setVisible(e, showContainers); });\n        if (!showContainers) {\n            return;\n        }\n        var viewportWidth;\n        var wrapperWidth;\n        if (utils_1.Utils.isVerticalScrollShowing(this.eLeftViewport)) {\n            if (this.enableRtl) {\n                // show the scroll\n                viewportWidth = '100%';\n                wrapperWidth = widthOfCols + this.scrollWidth;\n            }\n            else {\n                // hide the scroll, this makes the wrapper clip the scroll\n                viewportWidth = \"calc(100% + \" + this.scrollClipWidth + \"px)\";\n                wrapperWidth = widthOfCols;\n            }\n        }\n        else {\n            // no scroll\n            viewportWidth = '100%';\n            wrapperWidth = widthOfCols;\n        }\n        this.eLeftViewport.style.width = viewportWidth;\n        this.eLeftViewportWrapper.style.maxWidth = wrapperWidth + 'px';\n        // .width didn't do the trick in firefox, so needed .minWidth also\n        this.eLeftContainer.style.width = widthOfCols + 'px';\n        this.eLeftContainer.style.minWidth = widthOfCols + 'px';\n        this.eLeftBottom.style.maxWidth = wrapperWidth + 'px';\n        this.eLeftTop.style.maxWidth = wrapperWidth + 'px';\n    };\n    GridPanel.prototype.setPinnedRightWidth = function () {\n        var widthOfCols = this.columnController.getPinnedRightContainerWidth();\n        var visible = !this.printLayout && widthOfCols > 0;\n        var eParentContainers = [this.eRightViewportWrapper, this.eRightTop, this.eRightBottom];\n        eParentContainers.forEach(function (e) { return utils_1.Utils.setVisible(e, visible); });\n        if (!visible) {\n            return;\n        }\n        var viewportWidth;\n        var wrapperWidth;\n        if (utils_1.Utils.isVerticalScrollShowing(this.eRightViewport)) {\n            if (!this.enableRtl) {\n                // show the scroll\n                viewportWidth = '100%';\n                wrapperWidth = widthOfCols + this.scrollWidth;\n            }\n            else {\n                // hide the scroll, this makes the wrapper clip the scroll\n                viewportWidth = \"calc(100% + \" + this.scrollClipWidth + \"px)\";\n                wrapperWidth = widthOfCols;\n            }\n        }\n        else {\n            // no scroll\n            viewportWidth = \"100%\";\n            wrapperWidth = widthOfCols;\n        }\n        this.eRightViewport.style.width = viewportWidth;\n        this.eRightViewportWrapper.style.maxWidth = wrapperWidth + 'px';\n        // .width didn't do the trick in firefox, so needed .minWidth also\n        this.eRightContainer.style.width = widthOfCols + 'px';\n        this.eRightContainer.style.minWidth = widthOfCols + 'px';\n        this.eRightTop.style.maxWidth = wrapperWidth + 'px';\n        this.eRightBottom.style.maxWidth = wrapperWidth + 'px';\n    };\n    GridPanel.prototype.setPinnedContainersVisible = function () {\n        var changeDetected = false;\n        var showLeftPinned = this.printLayout ? false : this.columnController.isPinningLeft();\n        if (showLeftPinned !== this.pinningLeft) {\n            this.pinningLeft = showLeftPinned;\n            this.headerRootComp.setLeftVisible(showLeftPinned);\n            utils_1.Utils.setVisible(this.eLeftViewportWrapper, showLeftPinned);\n            changeDetected = true;\n            if (showLeftPinned) {\n                // because the viewport was not visible, it was not keeping previous scrollTop values\n                this.eLeftViewport.scrollTop = this.eBodyViewport.scrollTop;\n            }\n        }\n        var showRightPinned = this.printLayout ? false : this.columnController.isPinningRight();\n        if (showRightPinned !== this.pinningRight) {\n            this.pinningRight = showRightPinned;\n            this.headerRootComp.setRightVisible(showRightPinned);\n            utils_1.Utils.setVisible(this.eRightViewportWrapper, showRightPinned);\n            if (showRightPinned) {\n                // because the viewport was not visible, it was not keeping previous scrollTop values\n                this.eRightViewport.scrollTop = this.eBodyViewport.scrollTop;\n            }\n            changeDetected = true;\n        }\n        if (changeDetected) {\n            this.hideVerticalScrollOnCenter();\n            this.setPinnedLeftWidth();\n            this.setPinnedRightWidth();\n        }\n    };\n    GridPanel.prototype.hideVerticalScrollOnCenter = function () {\n        var neverShowScroll = this.enableRtl ?\n            this.columnController.isPinningLeft()\n            : this.columnController.isPinningRight();\n        var scrollActive = !this.printLayout && utils_1.Utils.isVerticalScrollShowing(this.eBodyViewport);\n        var hideScroll = neverShowScroll && scrollActive;\n        var margin = hideScroll ? '-' + this.scrollClipWidth + 'px' : '';\n        if (this.enableRtl) {\n            this.eBodyViewport.style.marginLeft = margin;\n        }\n        else {\n            this.eBodyViewport.style.marginRight = margin;\n        }\n    };\n    GridPanel.prototype.checkBodyHeight = function () {\n        var bodyHeight = this.eBody.clientHeight;\n        if (this.bodyHeight !== bodyHeight) {\n            this.bodyHeight = bodyHeight;\n            var event_3 = {\n                type: events_1.Events.EVENT_BODY_HEIGHT_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_3);\n        }\n    };\n    GridPanel.prototype.setBodyAndHeaderHeights = function () {\n        var headerRowCount = this.columnController.getHeaderRowCount();\n        var totalHeaderHeight;\n        var numberOfFloating = 0;\n        var groupHeight;\n        var headerHeight;\n        if (!this.columnController.isPivotMode()) {\n            if (this.gridOptionsWrapper.isFloatingFilter()) {\n                headerRowCount++;\n            }\n            numberOfFloating = (this.gridOptionsWrapper.isFloatingFilter()) ? 1 : 0;\n            groupHeight = this.gridOptionsWrapper.getGroupHeaderHeight();\n            headerHeight = this.gridOptionsWrapper.getHeaderHeight();\n        }\n        else {\n            numberOfFloating = 0;\n            groupHeight = this.gridOptionsWrapper.getPivotGroupHeaderHeight();\n            headerHeight = this.gridOptionsWrapper.getPivotHeaderHeight();\n        }\n        var numberOfNonGroups = 1 + numberOfFloating;\n        var numberOfGroups = headerRowCount - numberOfNonGroups;\n        totalHeaderHeight = numberOfFloating * this.gridOptionsWrapper.getFloatingFiltersHeight();\n        totalHeaderHeight += numberOfGroups * groupHeight;\n        totalHeaderHeight += headerHeight;\n        this.headerRootComp.setHeight(totalHeaderHeight);\n        var floatingTopHeight = this.pinnedRowModel.getPinnedTopTotalHeight();\n        var floatingBottomHeight = this.pinnedRowModel.getPinnedBottomTotalHeight();\n        this.eTop.style.minHeight = floatingTopHeight + 'px';\n        this.eTop.style.height = floatingTopHeight + 'px';\n        this.eBottom.style.minHeight = floatingBottomHeight + 'px';\n        this.eBottom.style.height = floatingBottomHeight + 'px';\n        this.checkBodyHeight();\n    };\n    GridPanel.prototype.getBodyHeight = function () {\n        return this.bodyHeight;\n    };\n    GridPanel.prototype.setHorizontalScrollPosition = function (hScrollPosition) {\n        this.eBodyViewport.scrollLeft = hScrollPosition;\n        // we need to manually do the event handling (rather than wait for the event)\n        // for the alignedGridsService, as if we don't, the aligned grid service gets\n        // notified async, and then it's 'consuming' flag doesn't get used right, and\n        // we can end up with an infinite loop\n        if (this.nextScrollLeft !== hScrollPosition) {\n            this.nextScrollLeft = hScrollPosition;\n            this.doHorizontalScroll();\n        }\n    };\n    GridPanel.prototype.setVerticalScrollPosition = function (vScrollPosition) {\n        this.eBodyViewport.scrollTop = vScrollPosition;\n    };\n    // tries to scroll by pixels, but returns what the result actually was\n    GridPanel.prototype.scrollHorizontally = function (pixels) {\n        var oldScrollPosition = this.eBodyViewport.scrollLeft;\n        this.setHorizontalScrollPosition(oldScrollPosition + pixels);\n        var newScrollPosition = this.eBodyViewport.scrollLeft;\n        return newScrollPosition - oldScrollPosition;\n    };\n    // tries to scroll by pixels, but returns what the result actually was\n    GridPanel.prototype.scrollVertically = function (pixels) {\n        var oldScrollPosition = this.eBodyViewport.scrollTop;\n        this.setVerticalScrollPosition(oldScrollPosition + pixels);\n        var newScrollPosition = this.eBodyViewport.scrollTop;\n        return newScrollPosition - oldScrollPosition;\n    };\n    GridPanel.prototype.addScrollListener = function () {\n        var _this = this;\n        this.addDestroyableEventListener(this.eBodyViewport, 'scroll', function (e) {\n            _this.onBodyHorizontalScroll();\n            _this.onAnyBodyScroll(_this.eBodyViewport);\n        });\n        this.addDestroyableEventListener(this.eRightViewport, 'scroll', this.onAnyBodyScroll.bind(this, this.eRightViewport));\n        this.addDestroyableEventListener(this.eLeftViewport, 'scroll', this.onAnyBodyScroll.bind(this, this.eLeftViewport));\n        this.addDestroyableEventListener(this.eFullWidthViewport, 'scroll', this.onAnyBodyScroll.bind(this, this.eFullWidthViewport));\n    };\n    GridPanel.prototype.eventDueToMakingContainerVisible = function (source) {\n        if (source.scrollTop !== 0) {\n            return false;\n        }\n        switch (source) {\n            case this.eBodyViewport:\n                return this.rowContainerComponents.body.isMadeVisibleRecently();\n            case this.eLeftViewport:\n                return this.rowContainerComponents.pinnedLeft.isMadeVisibleRecently();\n            case this.eRightViewport:\n                return this.rowContainerComponents.pinnedRight.isMadeVisibleRecently();\n            case this.eFullWidthViewport:\n                return this.rowContainerComponents.fullWidth.isMadeVisibleRecently();\n            default: return false;\n        }\n    };\n    GridPanel.prototype.onAnyBodyScroll = function (source) {\n        var now = new Date().getTime();\n        // when a row container becomes visible, it fires and event to say 'scroll at zero' which we don't want.\n        // this caused a problem in particular with SSRM where the loading stub cell was using full width (and\n        // hence the fullWidth row container was visible) and then when loading was done, the full width row\n        // goes, and then left with no full with rows so the full with row container is made not visible.\n        // the showing / hiding of the full width container was causing scroll events to zero scroll position\n        // to be fired. if we act on these events, it would result in the scroll resetting back to the top.\n        // we avoid this be skipping these events. this problem only appears to happen with Chrome.\n        if (this.eventDueToMakingContainerVisible(source)) {\n            return;\n        }\n        // recentScrolls: when one scrollable area is scrolling (eg center) then the\n        // other scroll areas are also scrolled (eg pinned left, pinned right, full width).\n        // we want to ignore events that are as a result of the other panels scrolling,\n        // eg if body scrolls to 100px, then we want to ignore the events coming from\n        // the other panels for 100px. if we don't do this, then we will end up with events\n        // interfering wih the scroll when there is a stream of events. this was most notable\n        // on IE, but impacted all browsers to some extent.\n        var lastTimeScrolledToHere = this.recentScrolls[source.scrollTop];\n        var scrolledToHereRecently = lastTimeScrolledToHere && ((now - lastTimeScrolledToHere) < 250);\n        if (scrolledToHereRecently) {\n            return;\n        }\n        this.recentScrolls[source.scrollTop] = now;\n        this.lastVScrollElement = source;\n        var scrollTop = source.scrollTop;\n        if (this.useAnimationFrame) {\n            if (this.nextScrollTop !== scrollTop) {\n                this.nextScrollTop = scrollTop;\n                this.animationFrameService.schedule();\n            }\n        }\n        else {\n            if (scrollTop !== this.scrollTop) {\n                this.scrollTop = scrollTop;\n                this.synchroniseVerticalScrollPositions(scrollTop);\n                this.redrawRowsAfterScroll();\n            }\n        }\n    };\n    GridPanel.prototype.onBodyHorizontalScroll = function () {\n        var supportsOverflowScrolling = this.animationFrameService.isSupportsOverflowScrolling();\n        var _a = this.eBodyViewport, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n        // in chrome, fractions can be in the scroll left, eg 250.342234 - which messes up our 'scrollWentPastBounds'\n        // formula. so we floor it to allow the formula to work.\n        var scrollLeft = Math.floor(utils_1.Utils.getScrollLeft(this.eBodyViewport, this.enableRtl));\n        // touch devices allow elastic scroll - which temporally scrolls the panel outside of the viewport\n        // (eg user uses touch to go to the left of the grid, but drags past the left, the rows will actually\n        // scroll past the left until the user releases the mouse). when this happens, we want ignore the scroll,\n        // as otherwise it was causing the rows and header to flicker.\n        var scrollWentPastBounds = scrollLeft < 0 || (scrollLeft + clientWidth > scrollWidth);\n        if (scrollWentPastBounds) {\n            return;\n        }\n        if (this.nextScrollLeft !== scrollLeft) {\n            this.nextScrollLeft = scrollLeft;\n            // for touch devices, we found scrolling was jerky when combining overflow scrolling and ag-grid\n            // animation frames. so if overflow scroll is supported (which means user is typically on a tab or phone)\n            // we don't use the animation frame service for horizontal scrolling.\n            if (!this.useAnimationFrame || supportsOverflowScrolling) {\n                this.doHorizontalScroll();\n            }\n            else {\n                this.animationFrameService.schedule();\n            }\n        }\n    };\n    GridPanel.prototype.doHorizontalScroll = function () {\n        this.scrollLeft = this.nextScrollLeft;\n        var event = {\n            type: events_1.Events.EVENT_BODY_SCROLL,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            direction: 'horizontal',\n            left: this.scrollLeft,\n            top: this.scrollTop\n        };\n        this.eventService.dispatchEvent(event);\n        this.horizontallyScrollHeaderCenterAndFloatingCenter();\n        this.onHorizontalViewportChanged();\n    };\n    GridPanel.prototype.executeFrame = function () {\n        if (this.scrollLeft !== this.nextScrollLeft) {\n            this.doHorizontalScroll();\n            return true;\n        }\n        else if (this.scrollTop !== this.nextScrollTop) {\n            this.scrollTop = this.nextScrollTop;\n            this.synchroniseVerticalScrollPositions(this.scrollTop);\n            this.verticalRedrawNeeded = true;\n            return true;\n        }\n        else if (this.verticalRedrawNeeded) {\n            this.redrawRowsAfterScroll();\n            this.verticalRedrawNeeded = false;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    GridPanel.prototype.redrawRowsAfterScroll = function () {\n        var event = {\n            type: events_1.Events.EVENT_BODY_SCROLL,\n            direction: 'vertical',\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            left: this.scrollLeft,\n            top: this.scrollTop\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    // this gets called whenever a change in the viewport, so we can inform column controller it has to work\n    // out the virtual columns again. gets called from following locations:\n    // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged, API (doLayout)\n    GridPanel.prototype.onHorizontalViewportChanged = function () {\n        var scrollWidth = this.eBodyViewport.clientWidth;\n        var scrollPosition = this.getBodyViewportScrollLeft();\n        this.columnController.setVirtualViewportPosition(scrollWidth, scrollPosition);\n    };\n    GridPanel.prototype.getBodyViewportScrollLeft = function () {\n        // we defer to a util, as how you calculated scrollLeft when doing RTL depends on the browser\n        return utils_1.Utils.getScrollLeft(this.eBodyViewport, this.enableRtl);\n    };\n    GridPanel.prototype.setBodyViewportScrollLeft = function (value) {\n        // we defer to a util, as how you calculated scrollLeft when doing RTL depends on the browser\n        utils_1.Utils.setScrollLeft(this.eBodyViewport, value, this.enableRtl);\n    };\n    GridPanel.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function () {\n        var scrollLeft = this.getBodyViewportScrollLeft();\n        var offset = this.enableRtl ? scrollLeft : -scrollLeft;\n        this.headerRootComp.setHorizontalScroll(offset);\n        this.eBottomContainer.style.left = offset + 'px';\n        this.eTopContainer.style.left = offset + 'px';\n    };\n    GridPanel.prototype.synchroniseVerticalScrollPositions = function (position) {\n        if (this.lastVScrollElement !== this.eBodyViewport) {\n            this.eBodyViewport.scrollTop = position;\n        }\n        if (this.lastVScrollElement !== this.eLeftViewport && this.pinningLeft) {\n            this.eLeftViewport.scrollTop = position;\n        }\n        if (this.lastVScrollElement !== this.eRightViewport && this.pinningRight) {\n            this.eRightViewport.scrollTop = position;\n        }\n        if (this.lastVScrollElement !== this.eFullWidthViewport) {\n            this.eFullWidthViewport.scrollTop = position;\n        }\n        // the row containers need to remember the scroll position, as if they are made\n        // hidden / shown, the scroll position is lost\n        this.rowContainerComponents.body.setVerticalScrollPosition(position);\n        this.rowContainerComponents.pinnedLeft.setVerticalScrollPosition(position);\n        this.rowContainerComponents.pinnedRight.setVerticalScrollPosition(position);\n        this.rowContainerComponents.fullWidth.setVerticalScrollPosition(position);\n        this.redrawRowsAfterScroll();\n    };\n    GridPanel.prototype.addScrollEventListener = function (listener) {\n        this.eBodyViewport.addEventListener('scroll', listener);\n    };\n    GridPanel.prototype.removeScrollEventListener = function (listener) {\n        this.eBodyViewport.removeEventListener('scroll', listener);\n    };\n    __decorate([\n        context_1.Autowired('alignedGridsService'),\n        __metadata(\"design:type\", alignedGridsService_1.AlignedGridsService)\n    ], GridPanel.prototype, \"alignedGridsService\", void 0);\n    __decorate([\n        context_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], GridPanel.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_1.Autowired('columnController'),\n        __metadata(\"design:type\", columnController_1.ColumnController)\n    ], GridPanel.prototype, \"columnController\", void 0);\n    __decorate([\n        context_1.Autowired('rowRenderer'),\n        __metadata(\"design:type\", rowRenderer_1.RowRenderer)\n    ], GridPanel.prototype, \"rowRenderer\", void 0);\n    __decorate([\n        context_1.Autowired('pinnedRowModel'),\n        __metadata(\"design:type\", pinnedRowModel_1.PinnedRowModel)\n    ], GridPanel.prototype, \"pinnedRowModel\", void 0);\n    __decorate([\n        context_1.Autowired('eventService'),\n        __metadata(\"design:type\", eventService_1.EventService)\n    ], GridPanel.prototype, \"eventService\", void 0);\n    __decorate([\n        context_1.Autowired('context'),\n        __metadata(\"design:type\", context_1.Context)\n    ], GridPanel.prototype, \"context\", void 0);\n    __decorate([\n        context_1.Autowired('animationFrameService'),\n        __metadata(\"design:type\", animationFrameService_1.AnimationFrameService)\n    ], GridPanel.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        context_1.Autowired('navigationService'),\n        __metadata(\"design:type\", navigationService_1.NavigationService)\n    ], GridPanel.prototype, \"navigationService\", void 0);\n    __decorate([\n        context_1.Autowired('autoHeightCalculator'),\n        __metadata(\"design:type\", autoHeightCalculator_1.AutoHeightCalculator)\n    ], GridPanel.prototype, \"autoHeightCalculator\", void 0);\n    __decorate([\n        context_1.Autowired('columnAnimationService'),\n        __metadata(\"design:type\", columnAnimationService_1.ColumnAnimationService)\n    ], GridPanel.prototype, \"columnAnimationService\", void 0);\n    __decorate([\n        context_1.Autowired('autoWidthCalculator'),\n        __metadata(\"design:type\", autoWidthCalculator_1.AutoWidthCalculator)\n    ], GridPanel.prototype, \"autoWidthCalculator\", void 0);\n    __decorate([\n        context_1.Autowired('paginationAutoPageSizeService'),\n        __metadata(\"design:type\", paginationProxy_1.PaginationAutoPageSizeService)\n    ], GridPanel.prototype, \"paginationAutoPageSizeService\", void 0);\n    __decorate([\n        context_1.Autowired('beans'),\n        __metadata(\"design:type\", beans_1.Beans)\n    ], GridPanel.prototype, \"beans\", void 0);\n    __decorate([\n        context_1.Autowired('paginationProxy'),\n        __metadata(\"design:type\", paginationProxy_1.PaginationProxy)\n    ], GridPanel.prototype, \"paginationProxy\", void 0);\n    __decorate([\n        context_1.Autowired('columnApi'),\n        __metadata(\"design:type\", columnApi_1.ColumnApi)\n    ], GridPanel.prototype, \"columnApi\", void 0);\n    __decorate([\n        context_1.Autowired('gridApi'),\n        __metadata(\"design:type\", gridApi_1.GridApi)\n    ], GridPanel.prototype, \"gridApi\", void 0);\n    __decorate([\n        context_1.Autowired('dragService'),\n        __metadata(\"design:type\", dragService_1.DragService)\n    ], GridPanel.prototype, \"dragService\", void 0);\n    __decorate([\n        context_1.Autowired('selectionController'),\n        __metadata(\"design:type\", selectionController_1.SelectionController)\n    ], GridPanel.prototype, \"selectionController\", void 0);\n    __decorate([\n        context_1.Autowired('csvCreator'),\n        __metadata(\"design:type\", csvCreator_1.CsvCreator)\n    ], GridPanel.prototype, \"csvCreator\", void 0);\n    __decorate([\n        context_1.Autowired('mouseEventService'),\n        __metadata(\"design:type\", mouseEventService_1.MouseEventService)\n    ], GridPanel.prototype, \"mouseEventService\", void 0);\n    __decorate([\n        context_1.Autowired('focusedCellController'),\n        __metadata(\"design:type\", focusedCellController_1.FocusedCellController)\n    ], GridPanel.prototype, \"focusedCellController\", void 0);\n    __decorate([\n        context_1.Autowired('$scope'),\n        __metadata(\"design:type\", Object)\n    ], GridPanel.prototype, \"$scope\", void 0);\n    __decorate([\n        context_1.Autowired('scrollVisibleService'),\n        __metadata(\"design:type\", scrollVisibleService_1.ScrollVisibleService)\n    ], GridPanel.prototype, \"scrollVisibleService\", void 0);\n    __decorate([\n        context_1.Autowired('frameworkFactory'),\n        __metadata(\"design:type\", Object)\n    ], GridPanel.prototype, \"frameworkFactory\", void 0);\n    __decorate([\n        context_1.Autowired('valueService'),\n        __metadata(\"design:type\", valueService_1.ValueService)\n    ], GridPanel.prototype, \"valueService\", void 0);\n    __decorate([\n        context_1.Autowired('componentRecipes'),\n        __metadata(\"design:type\", componentRecipes_1.ComponentRecipes)\n    ], GridPanel.prototype, \"componentRecipes\", void 0);\n    __decorate([\n        context_1.Autowired('dragAndDropService'),\n        __metadata(\"design:type\", dragAndDropService_1.DragAndDropService)\n    ], GridPanel.prototype, \"dragAndDropService\", void 0);\n    __decorate([\n        context_1.Autowired('heightScaler'),\n        __metadata(\"design:type\", heightScaler_1.HeightScaler)\n    ], GridPanel.prototype, \"heightScaler\", void 0);\n    __decorate([\n        context_1.Autowired('enterprise'),\n        __metadata(\"design:type\", Boolean)\n    ], GridPanel.prototype, \"enterprise\", void 0);\n    __decorate([\n        context_1.Autowired('resizeObserverService'),\n        __metadata(\"design:type\", resizeObserverService_1.ResizeObserverService)\n    ], GridPanel.prototype, \"resizeObserverService\", void 0);\n    __decorate([\n        context_1.Optional('rangeController'),\n        __metadata(\"design:type\", Object)\n    ], GridPanel.prototype, \"rangeController\", void 0);\n    __decorate([\n        context_1.Optional('contextMenuFactory'),\n        __metadata(\"design:type\", Object)\n    ], GridPanel.prototype, \"contextMenuFactory\", void 0);\n    __decorate([\n        context_1.Optional('clipboardService'),\n        __metadata(\"design:type\", Object)\n    ], GridPanel.prototype, \"clipboardService\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eBody'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eBody\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eBodyViewport'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eBodyViewport\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eBodyContainer'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eBodyContainer\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eBodyViewportWrapper'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eBodyViewportWrapper\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eLeftContainer'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eLeftContainer\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eRightContainer'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eRightContainer\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eFullWidthViewportWrapper'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eFullWidthViewportWrapper\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eFullWidthViewport'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eFullWidthViewport\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eFullWidthContainer'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eFullWidthContainer\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eLeftViewport'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eLeftViewport\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eLeftViewportWrapper'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eLeftViewportWrapper\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eRightViewport'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eRightViewport\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eRightViewportWrapper'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eRightViewportWrapper\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eTop'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eTop\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eLeftTop'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eLeftTop\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eRightTop'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eRightTop\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eTopContainer'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eTopContainer\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eTopViewport'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eTopViewport\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eTopFullWidthContainer'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eTopFullWidthContainer\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eBottom'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eBottom\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eLeftBottom'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eLeftBottom\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eRightBottom'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eRightBottom\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eBottomContainer'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eBottomContainer\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eBottomViewport'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eBottomViewport\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('eBottomFullWidthContainer'),\n        __metadata(\"design:type\", HTMLElement)\n    ], GridPanel.prototype, \"eBottomFullWidthContainer\", void 0);\n    __decorate([\n        componentAnnotations_1.RefSelector('headerRoot'),\n        __metadata(\"design:type\", headerRootComp_1.HeaderRootComp)\n    ], GridPanel.prototype, \"headerRootComp\", void 0);\n    __decorate([\n        context_1.PreDestroy,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], GridPanel.prototype, \"destroy\", null);\n    __decorate([\n        context_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], GridPanel.prototype, \"init\", null);\n    return GridPanel;\n}(component_1.Component));\nexports.GridPanel = GridPanel;\n",null]}